Перем _Лог;
Перем _ФайлДжсон;
Перем _ИспользоватьОтносительныеПути;
Перем _ТекущийРабочийКаталог;

Процедура ПриСозданииОбъекта(Знач пФайлДжсон, Знач пЛог, Знач пИспользоватьОтносительныеПути = Ложь)
	
	_ФайлДжсон = пФайлДжсон;
	_Лог       = пЛог;
	_ИспользоватьОтносительныеПути = пИспользоватьОтносительныеПути;
	_ТекущийРабочийКаталог = "";

	Если _ИспользоватьОтносительныеПути Тогда

		файл = Новый Файл(".");
		_ТекущийРабочийКаталог = СтрЗаменить(файл.ПолноеИмя, "\", "/");

	КонецЕсли;

КонецПроцедуры

Процедура Записать(Знач пТаблицаРезультатовПроверки, Знач пФорматОтчета) Экспорт
	
	Если пФорматОтчета = ТипыФорматаОтчетаСонар.Формат_10_3 Тогда
		структ = РезультатПроверкиОбщийФорматОтчета_10_3(пТаблицаРезультатовПроверки);
	Иначе
		структ = РезультатПроверкиОбщийФорматОтчета_Устаревший(пТаблицаРезультатовПроверки);
	КонецЕсли;
	
	_Лог.Информация("Подготовлено к записи в джсон ошибок: %1, правил: %2", структ.issues.Количество(), структ.rules.Количество());
	
	ЗаписатьФайлJSON(структ);
	
КонецПроцедуры

Функция РезультатПроверкиОбщийФорматОтчета_Устаревший(пТаблицаРезультатовПроверки)
	
	результат = Новый Структура;
	результат.Вставить("issues", Новый Массив);
	результат.Вставить("rules", Новый Массив);
	
	источникПроверки = ИсточникПроверки();
	существующиеПравила = Новый Соответствие;
	
	Для каждого цСтрока Из пТаблицаРезультатовПроверки Цикл
		
		ruleId = ИдентификаторПравил(цСтрока);
		
		Если Не ЗначениеЗаполнено(ruleId) Тогда
			_Лог.Предупреждение("Пустой ruleId для %1", СообщениеОбОшибке(цСтрока));
		КонецЕсли;

		структОшибка = Новый Структура;
		структОшибка.Вставить("engineId", источникПроверки);
		структОшибка.Вставить("ruleId", ruleId);
		структОшибка.Вставить("primaryLocation", МестонахождениеОшибки(цСтрока));
		структОшибка.Вставить("type", ТипОшибки_Устаревший(цСтрока));
		структОшибка.Вставить("severity", ВажностьОшибки_Устаревший(цСтрока));
		структОшибка.Вставить("effortMinutes", ЗатратыНаИсправление(цСтрока));
		структОшибка.Вставить("secondaryLocations", ВторостепенноеМестонахождение(цСтрока));
		
		результат.issues.Добавить(структОшибка);
		
		Если существующиеПравила[ruleId] = Истина Тогда
			Продолжить;
		КонецЕсли;
		
		структПравила = Новый Структура;
		структПравила.Вставить("engineId", источникПроверки);
		структПравила.Вставить("ruleId", ruleId);
		структПравила.Вставить("name", ruleId);
		структПравила.Вставить("type", структОшибка.type);
		структПравила.Вставить("severity", структОшибка.severity);
		структПравила.Вставить("description", структОшибка.primaryLocation.message);
		
		результат.rules.Добавить(структПравила);
		
		существующиеПравила.Вставить(ruleId, Истина);
		
	КонецЦикла;

	Возврат результат;

КонецФункции

Функция РезультатПроверкиОбщийФорматОтчета_10_3(пТаблицаРезультатовПроверки)
	
	результат = Новый Структура;
	результат.Вставить("issues", Новый Массив);
	результат.Вставить("rules", Новый Массив);

	источникПроверки = ИсточникПроверки();
	
	существующиеПравила = Новый Соответствие;

	Для каждого цСтрока Из пТаблицаРезультатовПроверки Цикл
		
		ruleId = ИдентификаторПравил(цСтрока);
		
		Если Не ЗначениеЗаполнено(ruleId) Тогда
			_Лог.Предупреждение("Пустой ruleId для %1", СообщениеОбОшибке(цСтрока));
		КонецЕсли;

		структОшибка = Новый Структура;
		структОшибка.Вставить("ruleId", ruleId);
		структОшибка.Вставить("effortMinutes", ЗатратыНаИсправление(цСтрока));
		структОшибка.Вставить("primaryLocation", МестонахождениеОшибки(цСтрока));
		структОшибка.Вставить("secondaryLocations", ВторостепенноеМестонахождение(цСтрока));
		
		результат.issues.Добавить(структОшибка);
		
		Если существующиеПравила[ruleId] = Истина Тогда
			Продолжить;
		КонецЕсли;
		
		структПравила = Новый Структура;
		структПравила.Вставить("engineId", источникПроверки);
		структПравила.Вставить("id", ruleId);
		структПравила.Вставить("name", ruleId);
		структПравила.Вставить("description", структОшибка.primaryLocation.message);
		структПравила.Вставить("cleanCodeAttribute", АтрибутЧистогоКода_10_3(цСтрока));
		структПравила.Вставить("impacts", Новый Массив);
		
		ДанныеКачества = Новый Структура;
		ДанныеКачества.Вставить("softwareQuality", КачествоПО_10_3(цСтрока));
		ДанныеКачества.Вставить("severity", ВажностьОшибки_10_3(цСтрока));
		структПравила.impacts.Добавить(ДанныеКачества);

		результат.rules.Добавить(структПравила);

		существующиеПравила.Вставить(ruleId, Истина);
		
	КонецЦикла;
	
	Возврат результат;

КонецФункции

Функция ИсточникПроверки()
	
	Возврат "edt";
	
КонецФункции

Функция ИдентификаторПравил(Знач пДанные)
	
	Если ЗначениеЗаполнено(пДанные.Правило) Тогда
		
		Возврат пДанные.Правило;
	
	КонецЕсли;
	
	текстОшибки = пДанные.Описание;
	
	// Контекст ошибки всегда в конце, просто обрежем все, что после [
	
	начало = СтрНайти(текстОшибки, "[");
	
	Если начало > 0 Тогда
		
		текстОшибки = Лев(текстОшибки, начало - 1);
		
	КонецЕсли;
	
	текстОшибки = ЗаменитьТекстВКавычках(текстОшибки, """", "%1");
	текстОшибки = ЗаменитьТекстВКавычках(текстОшибки, "'", "%1");
	
	// Пояснение к ошибке нам не нужно
	
	начало = СтрНайти(текстОшибки, ":", НаправлениеПоиска.СКонца);
	
	Если начало > 0 Тогда
		
		текстОшибки = СокрЛП(Лев(текстОшибки, начало - 1));
		
	КонецЕсли;
	
	// Сонар не любит запятые в тексте правил
	текстОшибки = СтрЗаменить(текстОшибки, ",", "_");
	
	Возврат СокрЛП(текстОшибки);
	
КонецФункции

Функция ЗаменитьТекстВКавычках(Знач пСтрока, Знач пКавычка = """", Знач пТекстЗамены = "")
	
	ПозицияКавычки = СтрНайти(пСтрока, пКавычка);
	
	Пока ПозицияКавычки > 0 Цикл
		
		ПозицияЗакрывающейКавычки = СтрНайти(Сред(пСтрока, ПозицияКавычки + 1), пКавычка) + ПозицияКавычки;
		
		Если ПозицияЗакрывающейКавычки = 0 Тогда
			
			Прервать;
			
		КонецЕсли;
		
		пСтрока        = Лев(пСтрока, ПозицияКавычки - 1) + пТекстЗамены + Сред(пСтрока, ПозицияЗакрывающейКавычки + 1);
		ПозицияКавычки = СтрНайти(пСтрока, пКавычка);
		
	КонецЦикла;
	
	Возврат пСтрока;
	
КонецФункции

Функция МестонахождениеОшибки(Знач пДанные)
	
	структ = Новый Структура;
	
	структ.Вставить("message", СообщениеОбОшибке(пДанные));
	структ.Вставить("filePath", ПутьКФайлу(пДанные));
	структ.Вставить("textRange", КоординатыОшибки(пДанные));
	
	Возврат структ;
	
КонецФункции

Функция СообщениеОбОшибке(Знач пДанные)
	
	Возврат пДанные.Описание;
	
КонецФункции

Функция ПутьКФайлу(Знач пДанные)
	
	путь = пДанные.Путь;

	путь = СтрЗаменить(путь, "\", "/"); // винда может жить с прямым слешем, а вот линукс с обратным не очень

	Если _ИспользоватьОтносительныеПути Тогда

		путь = СтрЗаменить(путь, _ТекущийРабочийКаталог, ".");

	КонецЕсли;

	Возврат путь;
	
КонецФункции

Функция КоординатыОшибки(Знач пДанные)
	
	структ = Новый Структура;
	МинВалиднаяПозиция = 1;
	
	Попытка
		Позиция = Число(пДанные.НомерСтроки);
		структ.Вставить("startLine", ?(Позиция = 0, МинВалиднаяПозиция, Позиция)); // для сонара 0 невалидная строка
	Исключение
		_Лог.Ошибка("Не удалось преобразовать к числу номер строки: " + пДанные.НомерСтроки);
		структ.Вставить("startLine", МинВалиднаяПозиция);
	КонецПопытки;
	
	Возврат структ;
	
КонецФункции

Функция ТипОшибки_Устаревший(Знач пДанные)
	
	// BUG, VULNERABILITY, CODE_SMELL
	
	Если пДанные.Тип = "Ошибка"
		ИЛИ пДанные.Тип = "Ошибка конфигурации" Тогда
		
		Возврат "BUG";
		
	Иначе
		
		Возврат "CODE_SMELL";
		
	КонецЕсли;
	
КонецФункции

Функция ВажностьОшибки_Устаревший(Знач пДанные)
	
	// BLOCKER, CRITICAL, MAJOR, MINOR, INFO
	
	Если пДанные.Тип = "Ошибка"
		ИЛИ пДанные.Тип = "Ошибка конфигурации" Тогда
	
		Возврат "CRITICAL";

	ИначеЕсли пДанные.Серьезность = "Предупреждение" Тогда
		
		Возврат "MINOR";

	Иначе
		
		Возврат "MINOR";
		
	КонецЕсли;
	
КонецФункции

Функция АтрибутЧистогоКода_10_3(Знач пДанные)
	
	// BSLLS:DuplicateStringLiteral-off
	АтрибутПоУмолчанию = "CONVENTIONAL";

	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Ошибка", "LOGICAL");
	Соответствие.Вставить("Ошибки конфигурации", "LOGICAL");
	Соответствие.Вставить("Предупреждение", "CONVENTIONAL");
	Соответствие.Вставить("Безопасность", "TRUSTWORTHY");
	Соответствие.Вставить("Производительность", "EFFICIENT");
	Соответствие.Вставить("Переносимость", "MODULAR");
	Соответствие.Вставить("Разработка и использование библиотек", "CONVENTIONAL");
	Соответствие.Вставить("Стандарты кодирования", "FORMATTED");
	Соответствие.Вставить("Стандарты разработки интерфейсов", "CONVENTIONAL");
	Соответствие.Вставить("Орфография", "CONVENTIONAL");
	Соответствие.Вставить("Критическая проблема целостности данных", "LOGICAL");

	Атрибут = Соответствие.Получить(пДанные.Тип);

	Если Атрибут = Неопределено Тогда

		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		Атрибут = Соответствие.Получить(пДанные.Серьезность);

		Если Атрибут = Неопределено Тогда
			Атрибут = АтрибутПоУмолчанию;
		КонецЕсли;

	КонецЕсли;

	Возврат Атрибут;

КонецФункции

Функция КачествоПО_10_3(Знач пДанные)
	
	// BSLLS:DuplicateStringLiteral-off

	// MAINTAINABILITY,RELIABILITY,SECURITY
	КачествоПОПоУмолчанию = "MAINTAINABILITY";

	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Ошибка", "RELIABILITY"); 
	Соответствие.Вставить("Ошибки конфигурации", "RELIABILITY");
	Соответствие.Вставить("Предупреждение", "MAINTAINABILITY");
	Соответствие.Вставить("Безопасность", "SECURITY");
	Соответствие.Вставить("Производительность", "RELIABILITY");
	Соответствие.Вставить("Переносимость", "MAINTAINABILITY");
	Соответствие.Вставить("Разработка и использование библиотек", "MAINTAINABILITY");
	Соответствие.Вставить("Стандарты кодирования", "MAINTAINABILITY");
	Соответствие.Вставить("Стандарты разработки интерфейсов", "MAINTAINABILITY");
	Соответствие.Вставить("Орфография", "MAINTAINABILITY");
	Соответствие.Вставить("Критическая проблема целостности данных", "RELIABILITY");
	
	КачествоПО = Соответствие.Получить(пДанные.Тип);

	Если КачествоПО = Неопределено Тогда

		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		КачествоПО = Соответствие.Получить(пДанные.Серьезность);

		Если КачествоПО = Неопределено Тогда
			КачествоПО = КачествоПОПоУмолчанию;
		КонецЕсли;

	КонецЕсли;

	Возврат КачествоПО;
	
КонецФункции

Функция ВажностьОшибки_10_3(Знач пДанные)
	
	// HIGH,MEDIUM,LOW
	ВажностьПоУмолчанию = "MEDIUM";

	Соответствие = Новый Соответствие;
	Соответствие.Вставить("Блокирующая", "HIGH");
	Соответствие.Вставить("Критическая", "HIGH");
	Соответствие.Вставить("Значительная", "MEDIUM");
	Соответствие.Вставить("Незначительная", "LOW");
	Соответствие.Вставить("Тривиальная", "LOW");
	
	Важность = Соответствие.Получить(пДанные.Серьезность);

	Если Важность = Неопределено Тогда

		// В edt 2023.2.4 другой порядок колонок Тип и Серьезность относительно метода edtExport.ИменаПолей.
		// Так же некоторые диагностики пишут Тип в Серьезность. Например "Функция не определена", "Не назначен обработчик для события жлемента формы".
		Важность = Соответствие.Получить(пДанные.Тип);

		Если Важность = Неопределено Тогда
			Важность = ВажностьПоУмолчанию;
		КонецЕсли;

	КонецЕсли;

	Возврат Важность;
	
КонецФункции

Функция ЗатратыНаИсправление(Знач пДанные)
	
	Возврат 0;
	
КонецФункции

Функция ВторостепенноеМестонахождение(Знач пДанные)
	
	Возврат Новый Массив;
	
КонецФункции

Процедура ЗаписатьФайлJSON(Знач пЗначение)
	
	ОбщегоНазначения.ЗаписатьJSONВФайл(пЗначение, _ФайлДжсон, _Лог);
	
КонецПроцедуры